<?xml version='1.0' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@2.8">
  <actions/>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <org.jenkinsci.plugins.workflow.job.properties.DisableConcurrentBuildsJobProperty/>
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers/>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2.22">
    <script>cleanNode(&apos;master&apos;) {
    // this stage could be on a roaming node iff it wasn&apos;t for the factory lsing
    stage(&apos;tag detection&apos;) {
        try {
            step([$class: &apos;CopyArtifact&apos;, projectName: env.JOB_NAME, selector: [$class: &apos;LastCompletedBuildSelector&apos;]])
        } catch(e) {}
        sh &apos;ssh-keygen -F git.neon.kde.org || ssh-keyscan -H git.neon.kde.org &gt;&gt; ~/.ssh/known_hosts&apos;
        sh &apos;ruby ~/tooling/nci/debian-merge/tagdetective.rb&apos;
        archiveArtifacts &apos;data.json&apos;
    }
    stage(&apos;merge&apos;) {
        sh &apos;ssh-keygen -F git.neon.kde.org || ssh-keyscan -H git.neon.kde.org &gt;&gt; ~/.ssh/known_hosts&apos;
        sh &apos;ruby ~/tooling/nci/debian-merge/merger.rb&apos;
    }
    stage(&apos;finalization&apos;) {
        stash includes: &apos;data.json&apos;, name: &apos;data&apos;
        deleteDir()
        unstash &apos;data&apos;
        sh &apos;ssh-keygen -F git.neon.kde.org || ssh-keyscan -H git.neon.kde.org &gt;&gt; ~/.ssh/known_hosts&apos;
        sh &apos;ruby ~/tooling/nci/debian-merge/finalizer.rb&apos;
    }
}

def cleanNode(label = null, body) {
  node(label) {
    deleteDir()
    try {
      body()
    } finally {
      step([$class: &apos;WsCleanup&apos;, cleanWhenFailure: true])
    }
  }
}
</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
</flow-definition>
