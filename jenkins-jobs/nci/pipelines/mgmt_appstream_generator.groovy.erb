env.DIST = '<%= dist %>'
env.TYPE = '<%= type %>'
env.APTLY_REPOSITORY = '<%= repo %>'
env.PWD_BIND = '/workspace'
env.PANGEA_DOCKER_IMAGE = 'debian:sid'

node('master') {
    wrap([$class: 'TimestamperBuildWrapper']) {
        wrap([$class: 'AnsiColorBuildWrapper', colorMapName: 'xterm']) {
            stage('cache[get]') {
                stash allowEmpty: true, includes: 'run/**, name: 'cache'
            }
        }
    }
}

node('cloud && amd64') {
    wrap([$class: 'TimestamperBuildWrapper']) {
        wrap([$class: 'AnsiColorBuildWrapper', colorMapName: 'xterm']) {
            stage('cache[unstash]') {
                sh 'rm -rfv *'
                unstash 'cache'
            }

            stage('clone[tooling]') {
                sh '[ -d tooling ] || mkdir tooling'
                dir('tooling') {
                    git branch: 'master', url: 'https://github.com/blue-systems/pangea-tooling'
                }
            }

            stage('generate') {
                sh 'tooling/nci/contain.rb $PWD_BIND/tooling/nci/asgen.sh'
            }

            stage('publish') {
                withCredentials([sshUserPrivateKey(credentialsId: 'ssh.jobs.archive.neon', keyFileVariable: 'SSH_KEY_FILE', passphraseVariable: '', usernameVariable: '')]) {
                    sh '~/tooling/nci/asgen_push.rb'
                }
            }

            stage('cache[new]') {
                // NB: we do not persist the export/ directory. This has two primary effects:
                // a) stashing is fairly fast
                // b) on subsequent runs export/ may not be fully populated
                // asgen only exports "new" data, so when it detects no change export/ will be
                // kind of empty. This basically allows us to skip asgen_push runs. BUT!
                // It also means that when rsyncing data to metadata.neon.kde.org we can't use
                // --delete since we'd drop still valid data. If and when the stash gets cleaned
                // out metadata also needs to get cleaned out!
                // In the grand scheme of things this is more efficient than stashing the export
                // but complicates the relationship between the two data sets. When in doubt
                // wipe all data and regenerate from scratch. That always creates a full data set.
                stash allowEmpty: false, includes: 'run/db/**, run/cache/**', name: 'new-cache'
            }
        }
    }
}

node('master') {
    wrap([$class: 'TimestamperBuildWrapper']) {
        wrap([$class: 'AnsiColorBuildWrapper', colorMapName: 'xterm']) {
            stage('cache[set]') {
                sh 'rm -rfv *'
                unstash 'new-cache'
            }
        }
    }
}
